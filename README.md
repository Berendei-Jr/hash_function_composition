# Hash Functions Composition Bruteforcer
## Средство вычисления прообраза нетривиальных композиций хеш-функций на OpenCL. Домашнее задание по курсу "Параллельные вычисления".

### Принцип работы:
#### Шаг 1
Для начала необходимо воспользоваться GUI утилитой composition_generator для выбора компощиции хеш-функций:
> python ./generator.py

![Full size](https://github.com/Berendei-Jr/hash_function_composition/img/gui.png)

В данном примере мы выбираем композицию
> md5(input) ^ sha512(input)

После нажатия кнопки "Скомпилировать программу" утилита определит порядок операция и сгенерирует файл main.cpp
с необходимой последовательностью операций (пример для данного примера находится в папке opencl_bruteforce_tool)

![Full size](https://github.com/Berendei-Jr/hash_function_composition/img/gui_2.png)

#### Шаг 2

Для компиляции и запуска OpenCL брутфорсера настроены файлы opencl_bruteforce_tool/.vscode/launch.json и opencl_bruteforce_tool/.vscode/tasks.json для VS Code

#### Шаг 3

Для оценки прироста производительности от распараллеливания был написан аналогичный брутфорсес на Python с использованием библиотеки hashlib (лежит в папке python_hashlib_bruteforce_tool).

Используя послеовательность команд, сгенерирванную GUI генератором, он выполняет аналогичные действия, но в одном потоке

Сравнение производительности наглядно видно на данных графиках:

![Full size](https://github.com/Berendei-Jr/hash_function_composition/img/graphic.png)

Для проверки вычислялась описанная выше композиция хеш-функций для чисел, являющихся степенями числа 10, начиная с 3. Перебор был последовательный, то есть вычислялись композии натуральных чисел начиная с 1, пока мы не получали искомый хеш.

Исходя из графиков видно, что на малых числах (до 10ˆ7) Python реализация не уступает и иногда превосходит OpenCL из-за меньших накладных расходов и большей мощности процессорного ядра, однако на больших числах время перебора экспоненциально возрастает.

Реализация на OpenCL имеет сильную недетерминированность по времени перебора на малых числах, что видно на графике, и от запуска к запуску это время меняется (например, видим, что 10ˆ6 было подобрано даже быстрее, чем 10ˆ3)

